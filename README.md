<div align='center'>
    <h1>Vim 命令速查表</h1>
</div>

<p align="center">
    <a href="./README.md">简体中文</a>
    •
    <a href="./README_EN.md">English</a>
</p>



> 简介：Vim 命令速查表，注释化 vimrc 配置文件，经典 Vim 键盘图，实用 Vim 书籍，Markdown 格式，目录化检索，系统化学习，体系化配置工具集，快速熟悉使用。✨

- [Vim-cheatsheet - GitHub](https://github.com/chloneda/vim-cheatsheet) | [Vim-cheatsheet - Gitee](https://gitee.com/chloneda/vim-cheatsheet)
- [Vim 官网](https://www.vim.org/) | [Vim GitHub](https://github.com/vim/vim) | [Vim 中文文档](http://vimcdoc.sourceforge.net/doc/help.html)
- [Vim 自定义跨平台配置文件 vimrc](./vimrc) | [Vim 体系化工具集](resources/vim-tools.md)



## 目录

* [重复的威力](#重复的威力)
* [光标移动](#光标移动)
* [插入模式](#插入模式)
* [插入模式的命令](#插入模式的命令)
* [自动补全](#自动补全)
* [文本编辑](#文本编辑)
* [文本对象](#文本对象)
* [移动文本](#移动文本)
* [文字排版](#文字排版)
* [复制粘贴](#复制粘贴)
* [撤销与恢复](#撤销与恢复)
* [查找替换](#查找替换)
* [可视模式](#可视模式)
* [注释命令](#注释命令)
* [打开文件](#打开文件)
* [保存退出](#保存退出)
* [文件比较](#文件比较)
* [文件操作](#文件操作)
* [缓冲区](#缓冲区)
* [分屏窗口](#分屏窗口)
* [标签页](#标签页)
* [Vim书签](#vim书签)
* [文件浏览器](#文件浏览器)
* [拼写检查](#拼写检查)
* [代码折叠](#代码折叠)
* [文档加解密](#文档加解密)
* [宏录制](#宏录制)
* [其它命令](#其它命令)
* [历史命令](#历史命令)
* [寄存器](#寄存器)
* [配置文件](#配置文件)
* [常用插件](#常用插件)
* [Vim模式](#vim模式)
* [外部命令](#外部命令)
* [GUI命令](#gui命令)
* [自动命令](#自动命令)
* [快速修复窗口](#快速修复窗口)
* [文件编码](#文件编码)
* [帮助信息](#帮助信息)
* [有点意思](#有点意思)
* [约定规范](#约定规范)
* [按键说明](#按键说明)
* [网络资源](#网络资源)
* [使用建议](#使用建议)
* [相关书籍](#相关书籍)
* [Vim键盘图](#vim键盘图)
* [参考信息](#参考信息)



## 重复的威力

```bash
.                   # 小数点，即重复（Dot）命令，重复执行上一次命令
N{command}          # 重复某个命令 N 次，例如：10k，光标上移 10 行
```

善用宏和正则表达式，同样可以达到减少重复操作的目的。



## 光标移动

> **注意：普通（Normal）模式下，任意一个动作都可以重复。**

```bash
                    # -------------------- 单位级移动 -------------------- 
h                   # 光标左移，等价于 <Left> 方向键（h 键位于左边，按该键光标左移）
j                   # 光标下移，等价于 <Down> 方向键（j 键有向下的突起，按该键光标下移）
k                   # 光标上移，等价于 <Up> 方向键 （k 键与 j 键相反，按该键光标上移）
l                   # 光标右移，等价于 <Right> 方向键（l 键位于右边，按下该键光标向右移动）
                    # -------------------- 单词级移动 --------------------
w                   # 移动到下一个标点或空格分隔的单词开头（w: word）
W                   # 移动到下一个空格分隔的单词开头（W: Word）
e                   # 移动到下一个标点或空格分隔的单词尾部（e: end）
E                   # 移动到下一个空格分隔的单词尾部（E: End）
b                   # 移动到上一个标点或空格分隔的单词开头（b: backward）
B                   # 移动到上一个空格分隔的单词开头（B: Backward）
                    # -------------------- 块级移动 ----------------------
0                   # 跳到行首，数字 0，等价于 <Home> 起始键
^                   # 跳到行首非空字符，可以使用 0w 代替 ^，按键更方便
$                   # 跳到行尾，等价于 <End> 结尾键
ge                  # 向后移动到单词词尾
gE                  # 向后移动到空白隔开的单词词尾
gg                  # 跳到第一行，等价于 Ctrl+<Home>
G                   # 跳到最后一行，等价于 Ctrl+<End>
[N]G                # 跳到第 N 行，例如 10G 是移动到第 10 行
:N                  # 跳到第 N 行，例如 :10<Enter> 是移动到第 10 行
N|                  # 移动到当前行的 N 列
{count}%            # 移动到文件百分之 {count} 的位置，例如 10% 是移动到文件 10% 的位置
<Enter>             # 移动到下一行首个非空字符
N<Enter>            # 光标向下移动 N 行
)                   # 向前移动一个句子（句号分隔）
(                   # 向后移动一个句子（句号分隔）
}                   # 向前移动一个段落（空行分隔）
{                   # 向后移动一个段落（空行分隔）
+                   # 移动到下一行首个非空字符，等价于 <Enter> 回车键
-                   # 移动到上一行首个非空字符
H                   # 移动到屏幕上部（H: High）
M                   # 移动到屏幕中部（M: Middle）
L                   # 移动到屏幕下部（L: Low）
gm                  # 移动到的行中间
gj                  # 光标向下移动一个屏幕行，非实际行，忽略自动换行
gk                  # 光标向上移动一个屏幕行，非实际行，忽略自动换行
<S+Up>              # 按住 <Shift> 上档键再按 <Up> 方向键，向上翻页
<S+Down>            # 按住 <Shift> 上档键再按 <Down> 方向键，向下翻页
<S+Left>            # 按住 <Shift> 上档键再按 <Left> 方向键，向左移动一个单词
<S+Right>           # 按住 <Shift> 上档键再按 <Right> 方向键，向右移动一个单词
:ju[mps]            # 输出所有跳转
:cle[arjumps]       # 清除所有跳转
                    # -------------------- 翻屏移动 ----------------------
zz                  # 调整光标所在行到屏幕中央
zt                  # 调整光标所在行到屏幕上部
zb                  # 调整光标所在行到屏幕下部
Ctrl+e              # 向上滚动一行（e: extra line）
Ctrl+y              # 向下滚动一行
Ctrl+u              # 向上滚动半屏（Move up 1/2 a screen）
Ctrl+d              # 向下滚动半屏（Move down 1/2 a screen）
Ctrl+f              # 向下滚动一屏（Move forward one full screen）
Ctrl+b              # 向上滚动一屏（Move back one full screen）
                    # -------------------- 编程辅助移动 ------------------
%                   # 不仅匹配跳转到对应的 {} () []，而且能在 if、else、elseif 之间跳跃
gd                  # 跳转到局部变量定义处，即光标下的单词的定义
gD                  # 跳转到全局变量定义处，即光标下的单词的定义
gf                  # 打开名称为光标下文件名的文件
[[                  # 跳转到上一个顶层函数，例如 C 语言以大括号分隔
]]                  # 跳转到下一个顶层函数，例如 C 语言以大括号分隔
[m                  # 跳转到上一个成员函数开头
]m                  # 跳转到下一个成员函数开头
]M                  # 跳转到下一个成员函数结尾
[M                  # 跳转到上一个成员函数结尾
[{                  # 跳转到上一处未匹配的 {
]}                  # 跳转到下一处未匹配的 }
[(                  # 跳转到上一处未匹配的 (
])                  # 跳转到下一处未匹配的 )
[c                  # 跳转到上一个不同处（diff 时）
]c                  # 跳转到下一个不同处（diff 时）
]]                  # 跳转到下一个第一列的 {
][                  # 跳转到下一个第一列的 }，和上面的对应
[[                  # 跳转到上一个第一列的 {
[]                  # 跳转到上一个第一列的 }
[/                  # 跳转到当前注释块开始处
]/                  # 跳转到当前注释块结尾处
]#                  # 跳转到上一个 if 或者 else 处
[#                  # 跳转到下一个 else 或者 endif 处
```

注意：块级 移动要善于使用 Vim 的**书签**和**标签页**功能，实现文件内容及文件之间快速移动。



## 插入模式

```bash
i                   # 在光标处进入插入模式（i: insert）
I                   # 在行首进入插入模式
a                   # 在光标后进入插入模式（a: append）
A                   # 在行尾进入插入模式
o                   # 在下一行插入新行并进入插入模式
O                   # 在上一行插入新行并进入插入模式
s                   # 删除光标所在的字符并进入插入模式
S                   # 删除当前行并插入文本 
gi                  # 进入到上一次插入模式的位置
gI                  # 在当前行第 1 列插入
<Esc>               # 退出插入模式
Ctrl+[              # 退出插入模式，等价于 <Esc> 退出键
Ctrl+C              # 退出插入模式，等价于 <Esc> 和 Ctrl+[，但不检查缩写
```



## 插入模式的命令

> 注意：由 i, I, a, A, o, O, s, S 等命令进入插入模式。

```bash
<Up>                # 光标向上移动
<Down>              # 光标向下移动
<Left>              # 光标向左移动
<Right>             # 光标向右移动
<S+Up>              # 按住 <Shift> 上档键再按 <Up> 方向键，向上翻页
<S+Down>            # 按住 <Shift> 上档键再按 <Down> 方向键，向下翻页
<S+Left>            # 按住 <Shift> 上档键再按 <Left> 方向键，向左移动一个单词
<S+Right>           # 按住 <Shift> 上档键再按 <Right> 方向键，向右移动一个单词
<PageUp>            # 向上翻页，<PageUp> 是向上翻页键
<PageDown>          # 向下翻页，<PageDown> 是向下翻页键
<Delete>            # 删除光标处字符，<Delete> 是删除键
<Backspace>         # 退格键 <Backspace> 向后删除字符
<Home>              # 光标跳转行首
<End>               # 光标跳转行尾
Ctrl+d              # 减少缩进光标所在行
Ctrl+f              # 自动缩进光标所在行（相当于普通模式下的 `==` ）
Ctrl+t              # 增加缩进光标所在行
Ctrl+h              # 删除前一个字符，等价于 <Backspace> 退格键
Ctrl+o              # 临时退出插入模式，执行单条命令又返回插入模式
Ctrl+u              # 当前行删除到行首所有字符
Ctrl+w              # 删除光标前的一个单词
Ctrl+\ Ctrl+O       # 临时退出插入模式（光标保持），执行单条命令又返回插入模式
Ctrl+R 0            # 插入寄存器（内部 0 号剪贴板）内容，Ctrl+R 后可跟寄存器名
Ctrl+R "            # 插入匿名寄存器内容，相当于插入模式下 p 粘贴
Ctrl+R =            # 插入表达式计算结果，等号后面跟表达式
Ctrl+R :            # 插入上一次命令行命令
Ctrl+R /            # 插入上一次搜索的关键字
Ctrl+v {char}       # 插入非数字的字面量
Ctrl+v {code}       # 插入用三位数字表示的 ASCII/Unicode 字符编码，例如 Ctrl+v 065
Ctrl+v 065          # 插入 10 进制 ASCII 字符（两数字） 065 即 A 字符
Ctrl+v x41          # 插入 16 进制 ASCII 字符（三数字） x41 即 A 字符
Ctrl+v o101         # 插入 8 进制 ASCII 字符（三数字） o101 即 A 字符
Ctrl+v u1234        # 插入 16 进制 Unicode 字符（四数字）
Ctrl+v U12345678    # 插入 16 进制 Unicode 字符（八数字）
Ctrl+K {ch1} {ch2}  # 插入 digraph（见 :h digraph），快速输入日文或符号等
```



## 自动补全

```bash
Ctrl+n              # 插入模式下文字自动补全，最常用的补全
Ctrl+P              # 插入模式下文字自动补全
Ctrl+e              # 有补全列表时，终止这次补全，继续输入

Ctrl+X              # 进入补全模式，注意：智能补全命令均以组合键 Ctrl+X 作为起始操作，下同
Ctrl+X Ctrl+L       # 补全整行
Ctrl+X Ctrl+N       # 插入模式下根据当前缓冲区关键字补全
Ctrl+X Ctrl+K       # 根据字典补全
Ctrl+X Ctrl+T       # 根据同义词字典补全
Ctrl+X Ctrl+F       # 插入模式下补全文件名
Ctrl+X Ctrl+I       # 根据头文件内关键字补全
Ctrl+X Ctrl+]       # 标签文件关键词补全
Ctrl+X Ctrl+D       # 补全宏定义
Ctrl+X Ctrl+V       # 补全 Vim 命令
Ctrl+X Ctrl+U       # 用户自定义补全方式
Ctrl+X Ctrl+S       # 拼写建议，例如：一个英文单词
Ctrl+X Ctrl+O       # 插入模式下全能 Omnifunc 补全
```



## 文本编辑

```bash
r                   # 替换当前字符（r: replace）
R                   # 进入替换模式，直至按 <Esc> 退出键离开
[N]s                # 替换 N 个字符，即删除光标后 N 个字符并进入插入模式
[N]S                # 替换 N 行，即删除 N 行并进入插入模式
[N]x                # 剪切、删除光标右边 N 个字符，相当于d[N]l
[n]X                # 剪切、删除光标左边 N 个字符，相当于d[n]h

cc                  # 改写当前行，即删除当前行并进入插入模式，等价于 S
cw                  # 改写光标开始处的当前单词
ciw                 # 改写光标所处的单词
caw                 # 改写光标所处的单词，并且包括前后空格
c0                  # 改写到行首
c^                  # 改写到行首非空字符
c$                  # 改写到行末
C                   # 改写到行尾，等价于 c$
ci"                 # 改写双引号中的内容，i 的含义下同（i: inner）
ci'                 # 改写单引号中的内容
cib                 # 改写小括号中的内容
cab                 # 改写小括号中的内容，包含小括号本身
ci)                 # 改写小括号中的内容
ci]                 # 改写中括号中内容
ciB                 # 改写大括号中内容
caB                 # 改写大括号中的内容，包含大括号本身
ci}                 # 改写大括号中内容
cit                 # 改写 XML 中 tag 的内容
cis                 # 改写当前句子
c[N]w               # 改写光标后 N 个单词
c[N]l               # 改写光标后 N 个字母
c[N]h               # 改写光标前 N 个字母
[N]cc               # 修改当前 N 行
ct(                 # 改写到小括号前

dd                  # 删除（剪切）当前行，当前行会存到寄存器里（d: delete = cut）
dd[N]p              # 删除（剪切）当前行并加入 N-1 个当前行，复制空行时很有用
d0                  # 删除（剪切）到行首
d^                  # 删除（剪切）到行首非零字符
d$                  # 删除（剪切）到行末
D                   # 删除（剪切）到行末，等价于 d$
dw                  # 删除（剪切）当前单词
diw                 # 删除（剪切）光标所处的单词（iw: inner word）
daw                 # 删除（剪切）光标所处的单词，并包含前后空格
d2w                 # 删除（剪切）下 2 个单词
d[N]w               # 删除（剪切）N 个单词，并包含前后空格
d[N]l               # 删除（剪切）光标右边 N 个字符
d[N]h               # 删除（剪切）光标左边 N 个字符
[N]dd               # 删除（剪切）从当前行开始的 N 行
:Nd                 # 删除（剪切）第 N 行
:N,Md<CR>           # 删除（剪切） N ~ M 行，其中 <CR> 为 <Enter> 回车键
di"                 # 删除（剪切）双引号中的内容
di'                 # 删除（剪切）单引号中的内容
dib                 # 删除（剪切）小括号中的内容
di)                 # 删除（剪切）小括号中的内容
dab                 # 删除（剪切）小括号内的内容，包含小括号本身
di]                 # 删除（剪切）中括号中内容
diB                 # 删除（剪切）大括号中内容
di}                 # 删除（剪切）大括号中内容
daB                 # 删除（剪切）大括号内的内容，包含大括号本身
dit                 # 删除（剪切） XML 中 tag 的内容
dis                 # 删除（剪切）当前句子
dt(                 # 删除（剪切）到小括号前
dgg                 # 删除（剪切）到文件头部
d1G                 # 删除（剪切）到文件头部，同上
dG                  # 删除（剪切）到文件尾部
d}                  # 删除（剪切）下一个段落
d{                  # 删除（剪切）上一个段落
d/f<CR>             # 比较高级的组合命令，它将删除 当前位置 到下一个字母 f 之间的内容，其中 <CR> 为 <Enter> 回车键

~                   # 转换大小写
g~iw                # 替换当前单词的大小写
gUiw                # 将单词转成大写
guiw                # 将当前单词转成小写
guu                 # 全行转为小写
gUU                 # 全行转为大写
Ctrl+A              # 增加数字
Ctrl+X              # 减少数字
```



## 文本对象

> **注意**：只适用于可视模式或在操作符后，例如：操作包括 **选择 v、删除 d、复制 y、修改 c** 等。

```bash
aw                  # 操作整个单词，不包括分隔符（aw: a word）
aW                  # 操作整个单词，包括分隔符（aW: a Word）
iw                  # 操作整个单词，不包括分隔符（iw: inner word）
iW                  # 操作整个单词，包括分隔符（iW: inner Word）
is                  # 操作整个句子，不包括分隔符 (s: sentence）
ib                  # 操作内含块，从 [( 到 ])（b: block）
iB                  # 操作内含大块，从 [{ 到 ]} （B: Block）
ab                  # 操作一个块，从 [( 至 ])（b: block）
aB                  # 操作一个大块，从 [{ 到 ]}（B: Block）
ap                  # 操作一个段落（p: paragraph）
ip                  # 操作内含段落
i)                  # 操作小括号字符串
a)                  # 操作小括号字符串，包含小括号本身
i]                  # 操作中括号字符串
a]                  # 操作中括号字符串，包含中括号本身
i}                  # 操作大括号字符串
a}                  # 操作大括号字符串，包含大括号本身
i'                  # 操作单引号字符串
a'                  # 操作单引号字符串，包含单引号本身
i"                  # 操作双引号字符串
a"                  # 操作双引号字符串，包含双引号本身
a`                  # 操作一个反引号字符串
i`                  # 操作内含反引号字符串
a>                  # 操作一个 <> 块
i>                  # 操作内含 <> 块
at                  # 操作一个标签块，例如 从 <aaa> 到 </aaa>（t: tag）
it                  # 操作内含标签块，例如 从 <aaa> 到 </aaa>
2i)                 # 操作往外两层小括号内
2a)                 # 操作往外两层小括号内，包含小括号本身
[N]f)               # 移动到第 N 个小括号处
[N]t)               # 移动到第 N 个小括号前
```

文本对象的配对括号、标点及配对标点内的内容的编辑修改对编程非常实用，可以简单总结为。

```bash
ci'、ci"、ci(、ci[、ci{、ci<                # 分别修改这些配对标点符号中的文本内容
ca'、ca"、ca(、ca[、ca{、ca<                # 分别修改这些配对标点符号中的文本内容，包括 标点符号 本身
di'、di"、di(、dib、di[、di{、diB、di<       # 分别删除这些配对标点符号中的文本内容
da'、da"、da(、dab、da[、da{、daB、da<       # 分别删除这些配对标点符号中的文本内容，包括 标点符号 本身
yi'、yi"、yi(、yi[、yi{、yi<                # 分别复制这些配对标点符号中的文本内容
ya'、ya"、ya(、ya[、ya{、ya<                # 分别复制这些配对标点符号中的文本内容，包括 标点符号 本身
vi'、vi"、vi(、vi[、vi{、vi<                # 分别选中这些配对标点符号中的文本内容
va'、va"、va(、va[、va{、va<                # 分别选中这些配对标点符号中的文本内容，包括 标点符号 本身
```



## 移动文本

移动文本命令格式。
```bash
:[range]m[ove]{address}
```

参数说明：
- [range]：表示要移动的行范围。
- {address}：表示移动的目标位置，这两个参数都可以缺省。

例如：
```bash
:m+1                # 下移 1 行
:m-2                # 上移 1 行
:8,10m2             # 把当前打开文件的第 8~10 行内容移动到第 2 行下方
```



## 文字排版

```bash
[N]>>                     # 向右缩进 N 行，单位为 shiftwidth
[N]<<                     # 向左缩进 N 行，单位为 shiftwidth
:ce[nter]                 # 本行文字居中
:le[ft]                   # 本行文字靠左
:ri[ght]                  # 本行文字靠右
:[range]ce[nter] [width]  # 在 range 范围行的文字居中
:[range]le[ft] [indent]   # 在 range 范围行的行文字靠左
:[range]ri[ght] [width]   # 在 range 范围行的行文字靠右
gq                        # 对选中的文字重排，即对过长文字进行断行
gqq                       # 重排当前行
gq[N]q                    # 重排 N 行
gqap                      # 重排当前段落
gq[N]ap                   # 重排 N 个段落
gq[N]j                    # 重排当前行和下面 N 行
gqQ                       # 重排当前段落到文章末尾
J                         # 将多行合并为一行
gj                        # 将多行合并为一行，且合并后不留空格
==                        # 自动缩进，当前文件所有行自动缩进对齐使用 gg=G
```



## 复制粘贴

复制命令的格式。

```bash
:[range]co[py]{address}
```

参数说明：
- [range]：表示要复制的行范围，其中 copy 可缩写为 :co 或 :t。
- {address}：表示复制的目标位置，这两个参数都可以缺省，用于表示 Vim 光标所在当前行。

例如：

```bash
:3copy.             # 复制文件的第 3 行到当前行（当前行用 . 表示）
:3,5t.              # 把第 3 行到第 5 行的内容复制到当前行下方
:t5                 # 把当前行复制到第 5 行下方
:t.                 # 复制当前行到当前行下方，等价于普通模式下的 yyp
:t$                 # 把当前行复制到文本结尾
:'<,'>t0            # 把高亮选中的行复制到文件开头
```

常用复制粘贴命令。

```bash
p                   # 粘贴到光标后（p: paste）
P                   # 粘贴到光标前
y                   # 复制标记内容
y0                  # 复制当前光标位置到行首的内容
y$                  # 复制当前位置到本行结束的内容
yy                  # 复制当前行（Yank (copy) a line ）
Y                   # 复制当前行，等价于 yy
yiw                 # 复制当前单词
y[N]w               # 复制 N 个单词
y[N]s               # 复制 N 个句子
[N]yy               # 复制光标下 N 行内容
ygg                 # 复制光标以上的所有行
y1G                 # 复制光标以上的所有行，同上
yG                  # 复制光标以下的所有行
yypVr{char}         # 复制字符并替换为等长指定字符，Markdown 编辑时尤为好用
:[range]y           # 复制范围，例如 :20,30y 是复制 20 到 30 行，:10y 是复制第 10 行
:[range]d           # 删除范围，例如 :20,30d 是删除（剪切） 20 到 30 行，:10d 是删除（剪切）第 10 行
"_[command]         # 使用 [command] 删除内容，并且不进行复制（不会污染寄存器）
"*[command]         # 使用 [command] 复制内容到系统剪贴板（需要 Vim 版本有 clipboard 支持）
```



## 撤销与恢复

```bash
[N]u                # 撤销命令，N 为任意整数，表示撤销 N 步操作，下同（u: undo）
[N]U                # 撤销整行操作，N 为任意整数
Ctrl+r              # 撤销上一次 u 命令（r: redo）
Ctrl+R              # 回退前一个命令
:earlier {N}s       # 回退到 N 秒前的文件内容，其中 s 可替换为 m（分）、h（小时）、d（天）
:later {N}s         # 前进 N 秒，其中 s 可替换为 m（分）、h（小时）、d（天）
```



## 查找替换

### 查找命令

普通（Normal）模式下的查找命令（注意：Esc 退出键可以中止大部分命令）。

```bash
/pattern            # 从光标处向文件尾搜索 pattern
?pattern            # 从光标处向文件头搜索 pattern
n                   # 向同一方向执行上一次搜索
N                   # 向相反方向执行上一次搜索
%                   # 匹配括号移动，包括 ()，{}，[]。结合以下两个命令相当强大。前提：需要把光标先移到括号上
*                   # 向后搜索光标所在的单词
#                   # 向前搜索光标所在的单词
<Shift>*            # 搜索光标所在位置的字符串，不用输入字符串，查询速度比 /pattern 快
f{char}             # 向后搜索当前行第一个为 {char} 的字符，Nfv 可以找到第 N 个为 v 字符，下同（f: find）
F{char}             # 向前搜索当前行第一个为 {char} 的字符
t{char}             # 向后搜索当前行第一个为 {char} 的字符前（t: to）
T{char}             # 向前搜索当前行第一个为 {char} 的字符前
;                   # 重复上次的字符查找命令（f/t 命令）
,                   # 反转方向查找上次的字符查找命令（f/t 命令）
tx                  # 搜索当前行到指定 字符串 之前
fx                  # 搜索当前行到指定 字符串 之处
<Esc>               # 放弃查找。例如，启动了 f 命令后发现想用的是 F 命令，<Esc> 退出键放弃查找
```



### substitute 命令替换

普通（Normal）模式下的替换命令格式。

```bash
:[range]s[ubstitute]/{pattern}/{string}/[flags]
```

参数说明：
- {pattern}：就是要被替换掉的字串，可以用 regexp 來表示。
- {string}：將 pattern 由 string 所取代。
- [range]：有以下一些取值。

| [range]取值 | 含义                                                  |
| :--------: | ----------------------------------------------------- |
| 无         | 默认光标所在行                                           |
| .          | 光标所在当前行                                          |
| N          | 第 N 行                                               |
| $          | 最后一行                                               |
| 'a         | 标记 a 所在的行（之前要用 ma 做过标记）                    |
| $-1        | 倒数第二行，可以对某一行加减某个数值获得确定的某行             |
| 1,10       | 第 1~10 行                                             |
| 1,$        | 第一行到最后一行                                         |
| 1,.        | 第一行到当前行                                           |
| .,$        | 当前行到最后一行                                         |
| 'a,'b      | 标记 a 所在的行 到 标记 b 所在的行（之前要用 ma、mb 做过标记） |
| %          | 所有行（和 1，$ 等价）                                    |
| ?str?      | 从当前位置向上搜索，找到第一个 str 的行（str 可以是正则）      |
| /str/      | 从当前位置向下搜索，找到第一个 str 的行（str 可以是正则）      |

**注意**：上面的所有用于 range 的表示方法都可以通过 +、- 操作来设置相对偏移量。

- [flags]有以下一些取值：


| [flags]取值 | 含义                                     |
| :---------: | --------------------------------------- |
| g           | 对指定范围内的所有匹配项（g: global）进行替换 |
| c           | 在替换前请求用户进行确认（c: confirm）       |
| e           | 忽略执行过程中的错误（e: error）            |
| i           | 不区分大小写（i: ignore）                  |
| 无          | 只在指定范围内的第一个匹配项进行替换          |

举例：

```bash
g&                        # 重复上一次 substitute 命令
:s/old/new/               # 当前行的第一个 old 替换为 new
:s/old/new/g              # 当前行的 old 全部替换为 new
:s/old/\U&/               # 当前行的 old 替换为大写的 OLD
:N,Ms/old/new/g           # 将第 N~M 行中所有的 old 全部替换为 new
:%s/old/new/g             # 当前文件中的 old 全部替换为 new
:%s/old/new/gc            # 将当前文件中的 old 全部替换为 new，并且每处询问你是否替换
:%s/^/xxx/g               # 在每行行首插入 xxx，^ 表示行首，注释时非常有用
:%s/./# &                 # 在非空行的行首添加注释，& 代表前边匹配到非空行字符
:%s/$/xxx/g               # 在每行行尾插入 xxx，$ 表示行尾
:%s/hello/&, world/       # 将会把 hello 替换成 hello, wolrd
:%s/.*/(&)/               # 将会把所有行用 () 包含起来
:%s/\s\+$//e              # 删除每行末尾的空格
:%s/1\\2\/3/123/g         # 将 "1\2/3" 替换为 "123"，特殊字符使用反斜杠标注
:%s/\r//g                 # 删除 DOS 换行符 ^M
:%s///gn                  # 统计某个模式的匹配个数
:%s/^\n$//gc/             # 替换多个空行为一个空行
:%s/\n/\r\r/              # 每行后加入空行
:%s/^\s*$\n//g            # 删除所有空白行
:%s/^M$//g                # 删除文件中显式的 ^M 符号，即操作系统换行符问题
:%s/_\(\w\)/\u\1/g        # 将下划线转为驼峰式写法
:%s/^\(\w\)/\L\1/g        # 将首字母大写的切换成小写
:h[elp] s[ubstitute]      # 查看 substitute 替换命令的帮助文档
```



### global 命令替换

> 还有一种比替换更灵活的方式，它允许匹配到某个指定模式后执行指定的 Ex 命令，即 Vim 的 global 命令，其处理重复工作的效率极高。其命令格式为：

```bash
:[range]g[lobal][!]/{pattern}/[cmd]
```

参数说明：
- [range]：表示操作范围，:global 命令的默认作用范围是整个文件 (用 % 表示)。 操作范围参考上面的 [range] 取值。
- [!]：表示反转 :global 命令的行为，将在没有匹配到指定模式的行上执行 cmd。
- {pattern}：指定 :global 命令要匹配的目标模式，若将该域留空，Vim 会自动使用当前(最近一次)的查找模式。
- [cmd]：除 :global 命令之外的任何 Ex 命令，Vim 缺省使用 :print 命令，缩写为 :p。

例如：

```bash
:g/pattern                  # 查找并显示文件中所有包含模式 pattern 的行，并移动到最后一个匹配处
:g/pattern/p                # 查找并显示文件中所有包含模式 pattern 的行
:g/\<pattern\>/p            # 查找并显示文件中所有精确匹配单词 pattern 的行
:g!/pattern/nu              # 查找并显示文件中所有不包含模式 pattern 的行，并显示这些行号
:v/pattern/d                # 删除所有不包含 pattern 的行
:g/.*/m0                    # 将所有的行按相反的顺序排列。其中，查找模式 .* 将匹配所有行，m0 命令将每一行移动到 0 行之后
:g/^/t.                     # 重复每一行，其中 :t 或 :copy 为复制命令
:g/^/+1 d                   # 删除偶数行
:g/^/d|m.                   # 删除奇数行
:g/^$/d                     # 删除所有空白行
:g/^\s*$/d                  # 删除所有空白行
:v/./d                      # 删除所有空白行，其中 . 用于匹配除换行符 \n 外的任何单字符
:g/pattern/d_               # 删除大量匹配行，避免花费不必要的时间拷贝匹配行至默认寄存器，可以指定黑洞寄存器 _
:N,Mg/pattern/p             # 查找并显示第 N 到 M 行之间所有包含模式 pattern 的行
:%g/^ xyz/normal dd         # 表示对于以一个空格和 xyz 开头的行，执行 Normal 模式下的 dd 命令
:g/.\n\n\@!/norm o          # 非空行每行后加入空行，且多个空行合并为一个空行，\n 末尾匹配换行符，\n\@! 表示 \n 紧接着 \n，则匹配失败
:h[elp] :g[lobal]           # 查看 global 命令的帮助文档
```

特别说明：
- substitute 与 global 形式很相似，都是要进行查找匹配，但 substitute 执行的是替换，而 global 执行的其它命令。
- global 命令实际上是分成两步执行：首先扫描 [range] 指定范围内的所有行，给匹配 {pattern} 的行打上标记；然后依次对打有标记的行执行 [cmd] 命令，如果被标记的行在对之前匹配行的命令操作中被删除、移动或合并，则其标记自动消失，而不对该行执行 [cmd] 命令。例子可以参考上面的奇数行、偶数行删除命令！



### 正则替换

> 高级的查找替换要用到正则表达式。详情可以查看下面的 正则表达式 命令的帮助文档。

```bash
:h[elp] pattern    # 查看 正则表达式 的帮助文档获取更多信息
```

> **注意：以下非 Vim 的命令，只代表正则表达式**。

```bash
                   # ---------------- 表示【目标字符集】的元字符 ---------------
[a-z]              # 表示匹配方括号中列举的任意一个字符，即匹配 a-z 中的任意一个字符
[^a-z]             # 表示匹配除 方括号中字符以外 的任意字符
.                  # 等价于 [^\n]，表示匹配 任意一个除换行符 ( \n ) 外的其他字符
\l                 # 等价于 [a-z]，表示匹配 任意一个小写字母
\L                 # 等价于 [^a-z]，表示匹配 任意一个除小写字母外的其他字符
\u                 # 等价于 [A-Z]，表示匹配 任意一个大写字母
\U                 # 等价于 [^A-Z]，表示匹配 任意一个除大写字母外的其他字符
\w                 # 等价于 [0-9A-Za-z_]，表示匹配 任意一个单词字母
\W                 # 等价于 [^0-9A-Za-z_]，表示匹配 任意一个除单词字母外的其他字符
\d                 # 等价于 [0-9]，表示匹配 任意一个阿拉伯数字
\D                 # 等价于 [^0-9]，表示匹配 任意一个除阿拉伯数字外的其他字符
\x                 # 等价于 [0-9A-Fa-f]，表示匹配 任意一个十六进制数字
\X                 # 等价于 [^0-9A-Fa-f]，表示匹配 任意一个除十六进制数字外的其他字符
                   # ---------------- 表示【次数】的元字符 ---------------------
*                  # 表示匹配 0 个或者任意个目标字符
\+                 # 表示匹配 1 个或者任意个目标字符
\?                 # 表示匹配 0 个或者1个目标字符
\{N,M}             # 表示匹配 N~M 个目标字符，即最少匹配 N 个目标字符，最多匹配 M-1 个目标字符
\{N}               # 表示匹配 N 个目标字符，即目标字符需连续出现 N 次
\{N,}              # 表示匹配 N 任意个目标字符，即最少匹配 N 个目标字符
\{,M}              # 表示匹配 0~M 个目标字符，即最多匹配 M-1 个目标字符，也可以不匹配字符
                   # ---------------- 表示【位置】的元字符 ---------------------
^                  # 表示匹配 输入字符串的开始位置 (行首)
$                  # 表示匹配 输入字符串的结束位置 (行尾)
\<                 # 表示匹配 单词词首
\>                 # 表示匹配 单词词尾
                   # ---------------- 表示【非打印字符】的元字符 ----------------
\n                 # 表示匹配 一个换行符
\r                 # 表示匹配 一个回车符 Enter 键
\t                 # 表示匹配 一个制表符 Tab 键
\s                 # 表示匹配 任意一个空白字符，包括空格、制表符、换页符等
\S                 # 表示匹配 任意一个非空白字符
                   # ---------------- 表示【子模式】的元字符 -------------------
()                 # 任何 () 内部的匹配文本被称为 子匹配，会被自动保存到临时的仓库中以便后续引用，可以用 \1-9 来依次引用子匹配
```



### Magic 模式

```bash
:h[elp] /magic     # 查看更多 Magic 模式帮助信息
```

Vim 正则表达式可以分为四种模式。

- magic 模式：使用 \m 前缀，其后模式的解释方式为 'magic' 选项。^，$，.，* 和 [] 等字符含有特殊意义；而 +、?、()、和 {} 等其它字符则按字面意义解释。magic为默认设置，表达式中的\m前缀可以省略。
- no magic 模式：使用 \M 前缀，其后模式的解释方式为 'nomagic' 选项。除了 ^ 和 $ 之外的特殊字符，都将被视为普通文本。
- very magic 模式：使用 \v 前缀，其后模式中除 '0'-'9'，'a'-'z'，'A'-'Z' 和 '_' 之外的字符都当作特殊字符解释。
- very nomagic 模式：使用 \V 前缀，其后模式中只有反斜杠（\）具有特殊意义。

不同模式之间的区别，在于哪些特殊字符需要使用反斜杠（\）进行转义。例如星号（*），在 magic 和 very magic 模式下视为特殊修饰符；而在 no magic 和 very nomagic 模式下则被视为普通字符，必须使用 “\*” 恢复其特殊作用。


## 可视模式

> Vim 可视模式下允许选中一块文本区域，并对文本区域进行 **复制 y、剪切 d、删除 d、替换 r、改变大小写** 等操作。

```bash
v                   # 切换到面向字符的可视模式（v: visual）
V                   # 切换到面向行的可视模式
Ctrl+v              # 切换到面向列块的可视模式
V>                  # 向右增加缩进
V<                  # 向左减少缩进
v0                  # 选中当前位置到行首
v$                  # 选中当前位置到行末
viw                 # 选中当前单词
vib                 # 选中小括号内的内容
vi)                 # 选中小括号内的内容
vi]                 # 选中中括号内的内容
viB                 # 选中大括号内的内容
vi}                 # 选中大括号内的内容
vis                 # 选中句子中的内容
vab                 # 选中小括号内的内容，包含小括号本身
va)                 # 选中小括号内的内容，包含小括号本身
va]                 # 选中中括号内的内容，包含中括号本身
vaB                 # 选中大括号内的内容，包含大括号本身
va}                 # 选中大括号内的内容，包含大括号本身
v[N]wd              # 删除（剪切）选中的 N 个单词
v[N]wc              # 修改高亮选中的 N 个单词，并进入插入模式
v[N]w~              # 高亮选中的 N 个单词转换大小写
{visual}o           # 跳转到可视模式选中区域的另一端（o: other end）
{visual}O           # 跳转到可视模式选中区域的另一端
{visual}u           # 标记区转换为小写
{visual}U           # 标记区转换为大写
gv                  # 重选上次的高亮选区
g Ctrl+G            # 显示所选择区域的统计信息
ggVG                # 选择全文
<Esc>               # 按 <Esc> 退出键退出可视模式
```



## 注释命令

```bash
Ctrl+v              # 多行注释 步骤1：进入命令行模式，按 Ctrl+v 进入可视模式，然后按 j 或者 k 字母键选中多行，把需要注释的行标记起来
I                   # 多行注释 步骤2：按大写字母 I 字母键，再插入注释符，例如 #、//
<Esc>               # 多行注释 步骤3：按 <Esc> 退出键就会全部注释了

Ctrl+v              # 取消多行注释 步骤1：进入命令模式，按 Ctrl+v 进入可视模式，按 l 字母键横向选中列的个数，例如 #、//，需要选中 2 列
j or k              # 取消多行注释 步骤2：按字母 j 或者 k 键移动选中注释符号
d                   # 取消多行注释 步骤3：按 d 字母键就可全部取消注释
```

复杂注释。

```bash
:N,M s/^/ 注释符 /g        # 在指定行 N ~ M 的行首添加注释（注意冒号）
:N,M s/^ 注释符 //g        # 在指定行 N ~ M 的行首取消注释（注意冒号）

:3,5 s/^/#/g              # 注释第 3 ~ 5 行
:3,5 s/^#//g              # 解除 3 ~ 5 行的注释

:1,$ s/^/#/g              # 注释整个文档
:1,$ s/^#//g              # 取消注释整个文档

:%s/^/#/g                 # 注释整个文档，此法更快
:%s/^#//g                 # 取消注释整个文档
```



## 打开文件

```bash
vim [options]             # 启动 Vim 并开启一个空白缓冲区
vim [options] {file} ..   # 启动并编辑一个或多个文件
vim [options] -           # 从标准输入读入文件
vim [options] -t {tag}    # 编辑与标签 tag 关联的文件
vim [options] -q [fname]  # 以快速修复模式开始编辑并显示首个错误。options 选项均参考以下

vim .                     # 打开文件管理器，显示目录文件，通过选中文件编辑
vim {file}                # 打开或新建文件，置于光标第一行首
vim + {file}              # 打开文件，置光标于最后一行首
vim +[N] {file}           # 打开文件，置光标于第 N 行首
vim -b {file}             # 以二进制模式打开文件，该模式某些特殊字符 如换行符 ^M 都可以显示出来
vim -v {file}             # Vi 模式，以普通模式启动 Ex
vim -e {file}             # Ex 模式，以 Ex 模式启动 vim  
vim -r {file}             # 恢复上次异常退出的文件
vim -R {file}             # 以只读的方式打开文件，但仍然可以使用 :wq! 写入
vim -M {file}             # 以只读的方式打开文件，不可以强制保存 :wq! 写入 
vim -x {file}             # 以加密方式打开文件
vim -p {files}            # 打开多个文件，每个文件占用一个标签页
vim -o {files}            # 在水平分割的多个窗口中编辑多个文件
vim -O {files}            # 在垂直分割的多个窗口中编辑多个文件
vim -c cmd {file}         # 在打开文件 file 前，先执行指定命令 cmd；vim file.txt -c "e ++enc=UTF-8"：以指定的编码打开 file.txt 文件
vim +{cmd} {file}         # 在打开文件 file 后，再执行命令 cmd
vim +/string {file}       # 打开文件 file，并将光标停留在第一个匹配的 string 上
vim -d {file1} {file2}    # 同时打开 file1 和 file2 文件并 diff 两个文件的差异
```



## 保存退出

```bash
:w                  # 写入文件并保存，会修改文件的时间戳
:w[rite] {file}     # 按名称 file 保存文件
:w !sudo tee %      # 以超级用户权限保存文件，也可以这样 :w !sudo tee % > /dev/null
:wa                 # 保存所有文件
:wa[ll]             # 保存所有文件
:wqa[ll]            # 保存所有文件并退出
:[N]wn[ext]         # 保存当前文件，并编辑下 N 个文件
:[N]wp[revious]     # 保存当前文件，并编辑上 N 个文件
:q                  # 关闭光标所在的窗口并退出
:q[uit]             # 关闭光标所在的窗口并退出
:q!                 # 不保存文件并强制退出
:qa[ll]             # 放弃所有文件操作并退出
:qa[ll]!            # 放弃所有文件操作并强制退出
:x                  # 保存文件并退出，不会修改文件的时间戳
ZZ                  # 保存已改动的文件，并关闭退出窗口，等价于 :x
ZQ                  # 不保存文件关闭窗口，等价于 :q!
```



## 文件比较

> Vim 的 diff 模式是依赖于 diff 命令的，所以首先保证系统中的 diff 命令是可用的。

```bash
vimdiff lfile rfile       # 纵向分割窗口比较文件
vim -d lfile  rfile       # 纵向分割窗口比较文件
vim -d -o lfile rfile     # 横向分割窗口比较文件

:diffs[plit] {file}       # 在当前窗口分割，载入另一个文件 file 进行文件比较 
:vert diffs {file}        # 在载入文件时要使用纵向分割
:difft[his]               # 将当前文件加入 diff
:diffp[atch] {patchfile}  # 将 buffer 中的文件载入当前窗口进行文件比较

:diffu[pdate]             # 文件改动后，刷新 diff
:diffu[pdate]!            # 对所有文件更新 diff

:[range]diffpu[t]         # 指定范围的合并，当前文件的指定范围内容复制到另一个文件里
:[range]diffg[et]         # 指定范围的合并，把另一个文件的指定范围内容复制到当前行中

]c                        # 在 diff 中的跳转到下一个不同
[c                        # 在 diff 中的跳转到上一个不同

:diffo[ff]                # 将目前文件退出 diff 模式
:diffo[ff]!               # 将目前窗口中的所有文件退出 diff 模式
:qa[ll]                   # 不保存文件修改并退出
:wa[ll]                   # 保存全部文件
:wqa[ll]                  # 修改合并后，保存全部文件并退出
```



## 文件操作

```bash
:e[dit] {file}      # 打开文件并编辑，通过文件的绝对或相对路径打开文件，Tab 制表键补全路径
:e[dit] .           # 打开文件管理器，浏览当前目录下的文件，选中并编辑 
:e[dit]             # 重新载入当前文件
:e[dit]!            # 放弃修改，重新回到文件打开时的状态  
:E[xplore]          # 打开文件管理器，并显示活动缓冲区所在的目录
:sav[eas] {file}    # 另存为指定文件 file
:o {file}           # 在当前窗口打开另一个文件（o: open）
:r {file}           # 读取文件并将内容插入到光标后
:r !dir             # 将 dir 命令的输出捕获并插入到光标后
:on[ly]             # 关闭除光标所在的窗口之外的其他窗口，等价于 Ctrl+W o
:clo[se]            # 关闭光标所在窗口的文件，等价于 Ctrl+W c
:cd {path}          # 切换 Vim 当前路径至 path
:cd -               # 回到上一次当前目录
:pwd                # 显示 Vim 当前路径
:n[ew] {file}       # 打开一个新的窗口编辑新文件 file 
:[N]new             # 打开 N 个新的窗口编辑新文件，N 为任意正整数
:ene[w]             # 在当前窗口创建新文件
:[N]vne[w]          # 纵向切分 N 个新窗口编辑新文件，N 为任意正整数
:tabnew             # 在新的标签页中编辑新文件
:fin[d] {file}      # 在 path 当中查找文件 file 并编辑
:f[ile]             # 显示当前文件名及光标位置
:f[ile] {name}      # 置当前文件名为 name
:files              # 查看缓冲区列表
```



## 缓冲区

> 缓冲区（Buffer）是一块内存区域，用于存储着正在编辑的文件。在保存缓冲区并退出时，内容也随之被写回原始文件。切换缓冲区可以在多个文件中来回编辑，提高编辑效率。

```bash
:ls                 # 查看缓冲区列表
:files              # 查看缓冲区列表，同上
:buffers            # 查看缓冲区列表，同上
:ls [flags]         # 查看指定状态的缓冲区，其中 [flags] 参考下面列表取值

:ball               # 为每个缓冲区打开一个窗口
:bad[d] {name}      # 将名称为 name 的文件添加到缓冲区列表
:b[uffer] [N]       # 打开指定缓存编号的缓冲区
:b[uffer] {name}    # 打开名称为 name 的缓冲区
:sb[uffer] [N]      # 纵向分割打开指定缓存编号的缓冲区
:sb[uffer] {name}   # 纵向分割打开名称为 name 的缓冲区

:bn[ext]            # 切换到下一个缓冲区
:bN[ext]            # 切换到上一个缓冲区
:bp[revious]        # 切换到上一个缓冲区，同上
:bf[irst]           # 切换到第一个缓冲区
:bl[ast]            # 切换到最后一个缓冲区

:bd[elete] [N]      # 删除指定 N 编号的缓冲区
:N,Mbdelete         # 删除指定范围的缓冲区，例如 :3,5bdelete 表示删除缓存编号在 3~5 范围的缓冲区
:bun[load][!] [N]   # 卸载缓冲区，! 代表是否强制卸载缓冲区
N Ctrl+^            # 切换缓冲区，先输入缓存编号，再按 Ctrl+^
```

查看缓冲区列表时，缓冲区状态包含以下几种：

| 缓冲区状态 | 说明                                                          |
| :------: | --------------------------------------------------------------|
|     +    | modified buffers，已更改的缓冲区                                 |
|     -    | buffers with 'modifiable' off，禁用了 modifiable 选项，只读缓冲区 |
|     =    | readonly buffers，只读缓冲区                                    |
|     a    | active buffers，活动缓冲区，显示在当前屏幕上                       |
|     u    | unlisted buffers (overrides the "!")                          |
|     h    | hidden buffers，隐藏缓冲区，已载入但没显示在屏幕上                  |
|     x    | buffers with a read error，读入时报错的缓冲区                    |
|     %    | current buffer，当前缓冲区                                      |
|     #    | alternate buffer，交换缓冲区                                    |
|     R    | terminal buffers with a running job                           |
|     F    | terminal buffers with a finished job                          |
|     ?    | terminal buffers without a job: `:terminal NONE`              |
|     t    | show time last used and sort buffers                          |




## 分屏窗口

> 分屏窗口是基于 Ctrl+W 快捷键的，Ctrl 是控制功能键，W 是代表 Windom，Ctrl+W 代表控制窗口的意思。

```bash
:sp[lit] {file}     # 横向切分窗口并在新窗口打开文件 file
:[N]sp[lit]         # 横向切分 N 个当前窗口出来，内容同步，游标可以不同
:[N]new             # 横向切分出一个 N 行高的窗口，并编辑一个新文件
:[N]sv[iew] {file}  # 横向切分窗口并在新窗口打开文件 file，等价于 :split，区别在于当前窗口的内容 只读
:[N]sf[ind] {file}  # 横向切分窗口，从 path 中找到文件 file 并编辑之
Ctrl+W s            # 横向切分当前窗口（s: split）
Ctrl+W f            # 横向切分出一个窗口，并在新窗口打开名称为光标所在词的文件

:vs[plit] {file}    # 纵向切分窗口并在新窗口打开文件 file（vs: vertical split）
:[N]vsp[lit]        # 纵向切分 N 个当前窗口出来，内容同步，游标可以不同
:[N]vne[w]          # 纵向切分出一个新窗口     
Ctrl+W v            # 纵向切分当前窗口（v:vertical split）

Ctrl+W c            # 关闭当前窗口，但不能关闭最后一个窗口，等价于 :clo[se]
Ctrl+W o            # 关闭其他窗口，只保留当前活动窗口，等价于 :on[ly]
Ctrl+W q            # 退出当前窗口，如果是最后一个窗口，则退出 Vim，等价于 :q[uit]

Ctrl+W h            # 跳转到左边的窗口（h 键位于左边，按该键光标左移）
Ctrl+W j            # 跳转到下边的窗口（j 键有向下的突起，按该键光标下移）
Ctrl+W k            # 跳转到上边的窗口（k 键与 j 键相反，按该键光标上移）
Ctrl+W l            # 跳转到右边的窗口（l 键位于右边，按下该键光标向右移动）
Ctrl+W H            # 移动当前窗口到最左边
Ctrl+W J            # 移动当前窗口到最下边
Ctrl+W K            # 移动当前窗口到最上边
Ctrl+W L            # 移动当前窗口到最右边
Ctrl+W              # 切换到下一个窗口（W: Window） 
Ctrl+W w            # 循环切换到下一个窗口 
Ctrl+W W            # 循环切换到上一个窗口 
Ctrl+W p            # 切换至上个访问过的窗口 
Ctrl+W r            # 反转互换窗口（r: reverse）
Ctrl+W T            # 将当前窗口移到新的标签页中
ctrl+W t            # 切换到最上面的窗口
ctrl+W b            # 切换到最下面的窗口
Ctrl+W P            # 跳转到预览窗口
Ctrl+W z            # 关闭预览窗口

Ctrl+W =                     # 设置所有窗口同宽同高
Ctrl+W _                     # 纵向最大化当前窗口
Ctrl+W |                     # 横向最大化当前窗口
Ctrl+W +                     # 增加当前窗口的行高，前面可以加数字
Ctrl+W -                     # 减少当前窗口的行高，前面可以加数字
Ctrl+W <                     # 减少当前窗口的列宽，前面可以加数字
Ctrl+W >                     # 增加当前窗口的列宽，前面可以加数字
:res[ize] <N>                # 调整当前窗口的高度，增加 N 行
:res[ize] +<N>               # 调整当前窗口的高度，增加 N 行
:res[ize] -<N>               # 调整当前窗口的高度，减小 N 行
:vert[ical] res[ize] <N>     # 调整当前窗口的宽度，增加 N 列
:vert[ical] res[ize] +<N>    # 调整当前窗口的宽度，增加 N 列
:vert[ical] res[ize] -<N>    # 调整当前窗口的宽度，减小 N 列
```



## 标签页

```bash
:tabs               # 显示所有标签页
:tabnew {file}      # 在新标签页中编辑新的文件 file
:tabe[dit] {file}   # 在新标签页中打开并编辑文件 file
:tabf[ind] {file}   # 在当前目录搜索 file，并在新标签页中打开。请注意，此命令只能打开一个文件
:tab split          # 在新的标签页中打开当前窗口里的文件
:tab ball           # 将缓存中所有文件用标签页打开
:tab drop {file}    # 如果文件已被其他标签页和窗口打开则跳过去，否则新标签打开

:tabc[lose]         # 关闭当前标签页
:tabo[nly]          # 关闭其他标签页

:tabn N             # 切换到第 N 个标签页，例如：tabn 3 切换到第 3 个标签页
:tabm[ove] N        # 将当前标签页移动到第 N 个标签页之后，标签页编号是从 0 开始计数的
:tabm[ove] +N       # 标签页往右移 N 个位置
:tabm[ove] -N       # 标签页往左移 N 个位置
:tabr[ewind]        # 切换到第一个标签页，等价于 :tabfirst 命令
:tabfir[st]         # 切换到第一个标签页
:tabl[ast]          # 切换到最后一个标签页
:tabn[ext]          # 切换到下一个标签页，等价于 gt
:tabp[revious]      # 切换到上一个标签页，等价于 gT
gt                  # 切换到下一个标签页
gT                  # 切换到上一个标签页
[N]gt               # 切换到第 N 个标签页，例如 2gt 将会切换到第 2 个标签页
:tabd[o] {cmd}      # 同时在多个标签页中执行命令，例如 :tabdo %s/food/drink/g，一次完成对所有文件的替换操作
:tab help           # 在标签页打开帮助
:h tabpage          # 查看标签页帮助文档
```



## vim书签

> Vim 书签可以在文件内容及文件之间快速定位到指定位置。

```bash
m{mark-name}                 # 创建名称为 mark-name 的书签
:marks                       # 查看并列出所有书签
:marks {mark-name}           # 查看名称为 mark-name 书签的详情信息
`{mark-name}                 # 跳转到书签的确切位置。请注意，此字符是后退引号
'{mark-name}                 # 跳转到书签行的开头。请注意，此字符是单引号
:delm[arks] {mark-name}      # 删除书签，可以批量删除
:delm[arks]!                 # 删除所有当前缓冲区的书签，但不包括 A-Z 和 0-9 的书签
:h marks                     # 查看书签帮助文档
```

例如：

```bash
:marks              # 查看所有书签
m{a-zA-Z}           # 创建书签，小写的是文件书签，大写的是全局书签，可以用 a-zA-Z 中的任何字母标记
ma                  # 保存当前位置到书签 a
:marks a            # 显示名称为 a 书签的详细信息
'a                  # 跳转到书签 a 所在的行
`a                  # 跳转到书签 a 所在位置
``                  # 回到上次跳转的位置
''                  # 回到上次跳转的位置
`.                  # 回到上次编辑的位置
'.                  # 回到上次编辑的位置
'A                  # 跳转到全局书签 A
['                  # 跳转到上一个书签
]'                  # 跳转到下一个书签
'<                  # 跳转到上次可视模式选择区域的开始
'>                  # 跳转到上次可视模式选择区域的结束
:delm a b           # 删除书签 a 和 b
:delmarks p-z       # 删除范围在 p ~ z 的书签
```



## 文件浏览器

> Vim 7.0 之后内置 Netrw 插件，提供文件浏览器功能，相比与 NERDTree 第三方插件来说速度更快，体量更轻，设计更简洁。

```bash
:[N]E[xplore][!] [dir]    # 当前窗口中打开文件浏览器
:[N]Hex[plore][!] [dir]   # 水平分割窗口打开文件浏览器
:[N]Lex[plore][!] [dir]   # 左边窗口打开文件浏览器
:[N]Sex[plore][!] [dir]   # 水平分割窗口打开文件浏览器
:[N]Vex[plore][!] [dir]   # 垂直分割窗口打开文件浏览器
:Tex[plore] [dir]         # 新标签页打开文件浏览器
:Rex[plore]               # 返回文件浏览器
:Nexplore                 # 定位到下一个匹配文件
:Pexplore                 # 定位到上一个匹配文件
:h[elp] netrw             # 查看更多 Netrw 插件的帮助信息
```



## 拼写检查

```bash
:set spell          # 打开拼写检查
:set nospell        # 关闭拼写检查
]s                  # 下一处错误拼写的单词
[s                  # 上一处错误拼写的单词
zg                  # 加入单词到拼写词表中
zug                 # 撤销上一次加入的单词
z=                  # 拼写建议
```



## 代码折叠

```bash
:h[elp] z           # 查看 折叠 帮助文档
zf{motion}          # 手动定义一个折叠（f:fold）
:{range}fold        # 将范围 {range} 包括的行定义为一个折叠
z=                  # 给出拼写建议
zf                  # 创建代码折叠
zF                  # 指定行数 N 创建折叠
za                  # 打开或关闭当前折叠
zA                  # 递归切换折叠，即递归打开一个关闭的折叠或关闭一个打开的折叠
zi                  # 切换折叠，切换 foldenable（i: invert）
zc                  # 关闭光标下的一个折叠（c: close）
zC                  # 递归关闭折叠（C: Close）
zj                  # 定位到下一个折叠处
zk                  # 定位到上一个折叠处
zd                  # 删除光标下折叠（d: delete）
zD                  # 递归删除折叠（D: Delete）
zE                  # 删除所有折叠
zm                  # 收起嵌套的折行，减少 foldlevel（m: more）
zM                  # 关闭所有折叠，置 foldlevel 为 0，设置 foldenable
zn                  # 不折叠，重置 foldenable 并打开所有代码（n: none）
zN                  # 正常折叠，重置 foldenable 并恢复所有折叠（N: Normal）
zr                  # 打开嵌套的折行，增加 foldlevel（r: reduce）
zR                  # 打开所有折叠，置 foldlevel 为最大值
zo                  # 打开光标下的折叠（o: open）
zO                  # 递归打开折叠（O: Open）
```



## 文档加解密

```bash
vim -x {file}       # 文档加密，输入加密密码并再次确认密码。注意：不修改内容也要保存，否则密码设定不会生效
:X                  # 文档加密，命令模式下输入加密密码并再次确认密码。注意：不修改内容也要保存，否则密码设定不会生效
:set key={password} # 文档加密，命令模式下输入加密密码并再次确认密码。注意：不修改内容也要保存，否则密码设定不会生效

:X                  # 文档解密，命令模式下直接按 <Enter> 回车键，表示密码为空。注意：不修改内容也要保存，否则解密设定不会生效
:set key=           # 文档解密，命令模式下设置 key 的密码为空。注意：不修改内容也要保存，否则密码设定不会生效
```



## 宏录制

> 宏是录制和播放功能，是一系列 Vim 命令操作的集成，利用宏可以减少很多重复的复杂操作。

```bash
q{0-9a-zA-Z"}       # 开始录制名字为 {0-9a-zA-Z"} 的宏，例如 qa 表示录制名字为 a 的宏
q                   # 结束录制宏
@{0-9a-z".=*+}      # 播放名字为 {0-9a-z".=*+} 的宏，例如 @a 表示播放名字为 a 的宏
@@                  # 播放上一个宏
@:                  # 重复上一个 Ex 命令，即冒号命令
```

**宏** 举例：需要将以下多行文本的行首键入一个 Tab 制表键进行 **行首缩进**。

```
set nu
set tabstop=4
set shiftwidth=4
set softtabstop=4
set autoindent
set wrap
syntax on
```

### 录制宏

1. 先将光标移动到第一行。
2. 在 Normal 模式下，按 q 字母键加一个字母开始录制。例如按下 qa，将该宏注册为 a。
3. 按下 I 字母键在行首插入，在编辑模式按下 Tab 制表键。按 <Esc> 退出键返回到 Normal 模式。
4. 按下 j 字母键将光标移动到下一行。
5. 按下 q 字母键完成录制。

### 使用宏

1. 使用上面录制的宏 a，按下 @a，播放名字为 a 的宏。
2. Normal 模式下将光标移动到第二行，按下 @a，再使用了一次宏 a。
3. 多次操作按下 N@a，其中 N 为正整数，代表执行 N 次宏。例如将光标移动到第 3 行，对余下的 5 行操作宏 a，按下 5@a。

以上 **录制宏、使用宏** 两个共同操作，完成多行文本的行首键入一个 Tab 制表键进行行首缩进！


## 其它命令

```bash
ga                  # 显示光标下字符的 ASCII 码或者 Unicode 编码
g8                  # 显示光标下字符的 UTF-8 编码字节序
gi                  # 回到上次进入插入的地方，并切换到插入模式
gH                  # 启动选择行模式
K                   # 查询光标下单词的帮助
Ctrl+G              # 显示正在编辑的文件名、文件大小和位置信息等信息
g Ctrl+G            # 显示文件的大小、字符数、单词数和行数，可视模式下也可用
Ctrl+PgUp           # 上个标签页，GVim OK，部分终端软件需设置对应键盘码
Ctrl+PgDown         # 下个标签页，GVim OK，部分终端软件需设置对应键盘码
Ctrl+R Ctrl+W       # 命令模式下插入光标下单词
Ctrl+Insert         # 复制到系统剪贴板（GVim）
Shift+Insert        # 粘贴系统剪贴板的内容（GVim）
Ctrl+X Ctrl+E       # 插入模式下向上滚屏
Ctrl+X Ctrl+Y       # 插入模式下向下滚屏
:.!date             # 在当前窗口插入时间
:%!xxd              # 开始二进制编辑
:%!xxd -r           # 保存二进制编辑
:r !curl -sL {URL}  # 读取 URL 内容添加到光标后
:v/./,/./-j         # 压缩空行
:Man bash           # 在 Vim 中查看 man，先调用 :runtime! ftplugin/man.vim 激活
/fred\|joe          # 搜索 fred 或者 joe
/\<\d\d\d\d\>       # 精确搜索四个数字
/^\n\{3}            # 搜索连续三个空行
```



## 历史命令

历史命令格式。

```bash
:his[tory] [{name}] [{first}][, [{last}]]
```

参数说明：

- {name}：指定历史记录类型。
- {first}：指定命令历史的起始位置，默认为第一条记录。
- {last}：指定命令历史的终止位置，默认为最后一条记录。

在命令行模式下。
```bash
:his[tory]                # 查看所有命令行模式下输入的命令历史
:his[tory] all            # 查看所有类型的历史记录
:history c 1,5            # 查看第一到第五条命令行历史
:history search 或 / 或 ? # 查看搜索历史
:call histdel("")         # 删除历史记录
:help :history            # 查看 :history 命令的帮助信息
```

在普通模式下。
```bash
q/                        # 查看使用 q/ 输入的搜索历史
q?                        # 查看使用 q? 输入的搜索历史
q:                        # 查看命令行历史
```



## 寄存器

> Vim 寄存器是用于保存临时数据的地方。Vim 有多个寄存器，可当作多个剪贴板，在使用多个文件时，此功能非常有用，且活用多个寄存器可以显著提高数据的安全和可操作性。

```bash
:reg[isters]              # 查看所有寄存器的值
:reg[isters] {args}       # 查看指定 {args} 中提到的寄存器值
"{register}               # 普通模式下调取寄存器值
:Ctrl+r "{reg-name}       # 命令模式下输入 Ctrl+r 后 Vim 会自动打出 " 寄存器引用符号
Ctrl+r {reg-name}         # 插入模式下无需输入寄存器引用符号 "
```

例如：

```bash
"?yy                # 复制当前行到寄存器 ? ，问号代表 0 ~ 9 的寄存器名称
"?d3j               # 删除光标下三行内容，并放到寄存器 ? ，问号代表 0 ~ 9 的寄存器名称
"?p                 # 将寄存器 ? 的内容粘贴到光标后
"?P                 # 将寄存器 ? 的内容粘贴到光标前
```

Vim 寄存器分类。

| 寄存器名称 &emsp;&emsp;&emsp;&emsp; | 引用方式 &emsp;&emsp;&emsp;&emsp; | 说明   |
| --------------- | ------------------ | ------------------------------------------------------------------ |
| 无名寄存器        | ""       | 默认寄存器，所有的复制和修改操作（x、s、d、c、y）都会将该数据复制到无名寄存器                |
| 字母寄存器        | "a-zA-Z  | {register} 只能是一位的 26 个英文字母，从 a-z，A-Z 寄存器内容将会合并到对应小写字母内容后边 |
| 复制专用寄存器     | "0       | 仅当使用复制操作(y)时，该数据将会同时被复制到无名寄存器和复制专用寄存器                     |
| 逐级临时缓存寄存器 | "1 - "9  | 所有不带范围（‘(’，‘)’，‘{’，‘}’）、操作涉及 1 行以上的删除修改操作（x、s、d、c）的数据都会复制到逐级临时缓存寄存器，并在新的数据加入时，逐级先后推移。1 的数据复制到 2，2 到 3，最后的 9 寄存器内容将会被删除 |
| 黑洞寄存器        | "_       | 几乎所有的操作涉及的数据都会被复制到寄存器，如果想让操作的数据不经过寄存器，可以指定黑洞寄存器，数据到该寄存器就会消失掉，不能显示，也不存在 |
| 系统剪切板        | "+ 或 "* | 与 Vim 外部的 GUI 交互数据时，需要使用专用的系统剪切板                                   |
| 表达式寄存器      | "=       | 所有寄存器里最特殊的一个，用于计算表达式。输入完该寄存器应用后，会在命令行里提示“=”，按需输入表达式，结果将会显示到光标处            |
| 其他寄存器        | -        | - |



## 配置文件

> Vim 配置文件有全局和用户两种版本，且用户配置文件优先于全局系统配置文件。

```bash
:ve[rsion]          # 查看 Vim 版本，同时也查看 Vim 载入配置文件的优先顺序及所在位置
:echo $MYVIMRC      # Vim 命令模式下使用该命令输出 Vim 配置文件的位置
:edit $MYVIMRC      # Vim 命令模式下使用该命令打开 Vim 配置文件
:so[urce] $MYVIMRC  # Vim 配置文件改动后，使用该命令加载新的配置选项，命令缩写为 :so %
:echo $VIM          # 输出全局 vimrc 配置文件位置，存放在 Vim 的安装目录中
:echo $HOME         # 输出用户 vimrc 配置文件位置，存放在用户主目录中
```

在命令行模式下单个设置选项，且选项只在当前窗口生效（命令前记得加上 “:” ，在 **[vimrc 配置文件](./vimrc)** 中则不需要）。

```bash
:se[t][!]                    # 显示出所有与其默认值不同的选项，当 [!] 出现时，每个选项都显示在单独的行上
:se[t][!] all                # 显示所有选项列表，当 [!] 出现时，每个选项都显示在单独的行上
:se[t] all&                  # 将所有的选项都重置为默认值
:se[t] {option}&             # 将选项设置为默认值
:se[t] {option}?             # 查看某个选项的当前值，屏幕底部将显示其返回值
:se[t] {option}              # 打开某个设置选项， 选项大致可分为三种：布尔值选项、数值选项和字符串选项
:se[t] no{option}            # 关闭某个设置选项
:se[t] {option}!             # 反转设置选项
:se[t] inv{option}           # 反转设置选项，同上
:se[t] {option}:{valus}      # 设置选项的值
:se[t] {option}={valus}      # 设置选项的值，同上
:se[t] {option}+={valus}     # 在选项中增加数值或增加字符串
:se[t] {option}-={valus}     # 在选项中减去数值或移除字符串
:se[t] {option}^={valus}     # 将选项乘以数值或在选项开头增加字符串
:setl[ocal]                  # 等价于 :set，但对局部选项设定其局部值
:setg[lobal]                 # 等价于 :set，但对局部选项设定其全局值
:h[elp] se[t]                # 查看命令的帮助信息
:map                         # 查看当前 Vim 配置的 map 映射快捷键
:inoremap                    # 查看当前 Vim 配置的 inoremap 映射快捷键
:nnoremap                    # 查看当前 Vim 配置的 nnoremap 映射快捷键
:unm[ap] {lhs}               # 取消 {lhs} 选项的映射，例如 :unmap <F10> 表示取消 F10 的映射
:mapclear                    # 取消所有映射；请注意，该命令将会移除所有用户定义和系统默认的键盘映射，慎用
:mapc[lear]!                 # 清除插入及命令行模式下的映射
:imapc[lear]                 # 清除插入模式下的映射
:vmapc[lear]                 # 清除可视模式下的映射
:omapc[lear]                 # 清除操作符等待模式下的映射
:nmapc[lear]                 # 清除普通模式下的映射
:cmapc[lear]                 # 清除命令行模式下的映射
:scr[iptnames]               # 查看 Vim 加载时加载了那些插件和脚本
```

**按键映射命令格式：**

```bash
[prefix]map {lhs} {rhs}      # 将键 {lhs} 映射为 {rhs}，{rhs} 可进行映射扫描，也可递归映射
```


参数说明：

- {lhs}：lhs 代表 left-hand-side，即左边参数。
- {rhs}：rhs 代表 right-hand-side，即右边参数。
- [prefix]：作用模式前缀，有以下取值。

|   前缀   | 作用模式                      | 命令格式               | 命令缩写            |
| :-----: | ---------------------------- | -------------------- | ------------------ |
| \<Space> | 普通、可视、选择和操作符等待      | :map {lhs} {rhs}     |  无                |
|    n    | 普通模式                       | :nmap {lhs} {rhs}    |  :nm {lhs} {rhs}   |
|    v    | 可视和选择模式                  | :vmap {lhs} {rhs}    |  :vm {lhs} {rhs}   |
|    s    | 选择模式                       | :smap {lhs} {rhs}    |  无                |
|    x    | 可视模式                       | :xmap {lhs} {rhs}    |  :xm {lhs} {rhs}   |
|    o    | 操作符等待                     | :omap {lhs} {rhs}    |  :om {lhs} {rhs}    |
|    !    | 插入和命令行模式                | :map! {lhs} {rhs}    |  无                 |
|    i    | 插入模式                       | :imap {lhs} {rhs}    |  :im {lhs} {rhs}   |
|    I    | 插入、命令行和 Lang-Arg 模式     | :lmap {lhs} {rhs}   |   :lm {lhs} {rhs}   |
|    c    | 命令行模式                     | :cmap {lhs} {rhs}    |   :lm {lhs} {rhs}  |
|  nore   | 不递归（no rerecursion）映射，和以上前缀自由搭配使用 | :noremap {lhs} {rhs} |   :nor {lhs} {rhs} |
|   un    | 取消 :map 绑定的 {lhs}         | :unmap {lhs}         |   无               |


{rhs} 之前可能显示的特殊字符：

| 特殊字符  |  意义                    |
| :-----: | ------------------------ |
|    *    | 不可重映射                |
|    &    | 仅脚本的局部映射可以被重映射 |
|    @    | 缓冲区的局部映射           |


特殊参数说明（特殊参数必须在映射命令的后边，{lhs} 参数的前面）：

|   参数      |  说明                                                                                |
| :--------: | ------------------------------------------------------------------------------------ |
| \<buffer>  | 如果映射命令的第一个参数是 <buffer> ，映射将只局限于当前缓冲区（即此时正在编辑的文件）内          |
| \<silent>  | 执行绑定键时不在命令行上回显按键映射的命令内容                                              |
| \<special> | 一般用于定义特殊键怕有副作用的场合                                                        |
| <script>   | 该映射只使用通过以 "<SID>" 开头来定义的脚本局部映射来重映射 {rhs} 中的字符                    |
|  \<expr>   | 如果定义新映射的第一个参数是 <expr> ，那么参数会作为表达式来进行计算，计算结果作为实际使用的 <rhs> |
| \<unique>  | 用于定义新的键映射或者缩写命令时检查是否该键已经被映射，如果该映射或者缩写已经存在，则该命令会失败   |


映射快捷键时常用的键表：

| 键              | 键说明         | 组合键                      |
| :------------: | ------------- | --------------------------- |
| \<F1> ~ \<F12> | 功能键 F1 ～ F12 |                           | 
| \<K0> ~ \<K9>  | 数值 0 到 9    |                             | 
| \<Shift>       | Shift 键      | <S-...> <s-...> <Shift-...> |
| \<Ctrl>        | Ctrl 键       | <C-...> <c-...> <Ctrl-...>  |
| \<Alt>         | Alt 键        | <A-...> <a-...> <Alt-...>   |
| \<Up>/\<Down>/\<Right>/\<Left> | 方向键 |                     |
| \<Esc>         |  Esc 键       |                             |
| \<Leader>      | \ 前缀键       |                             |
| \<Tab>         | Tab 制表键     |                             |
| \<CR>          | Enter 回车键   |                             |


在 **[vimrc 配置文件](./vimrc)** 中可以批量设置选项，例如：

```bash
syntax              # 列出已经定义的语法项
syntax clear        # 清除已定义的语法规则
syntax on           # 允许语法高亮
syntax off          # 禁止语法高亮
set nu              # 设置显示行号，禁止显示行号可以用 :set nonu
set number          # 设置显示行号，禁止显示行号可以用 :set nonumber
set list            # 设置显示制表符和换行符
set history=200     # 记录 200 条历史命令
set bs=?            # 设置 <Backspace> 退格键模式，现代编辑器为 :set bs=eol, start, indent
set sw=4            # 设置缩进宽度为 4
set ts=4            # 设置制表符宽度为 4
set noet            # 设置不展开 Tab 制表键成空格
set et              # 设置展开 Tab 制表键成空格
set winaltkeys=no   # 设置 GVim 下正常捕获 <Alt> 换挡键
set nowrap          # 关闭自动换行
set ttimeout        # 允许终端按键检测超时（终端下功能键为一串 Esc 开头的扫描码）
set ttm=100         # 设置终端按键检测超时为 100 毫秒
set term=?          # 设置终端类型，例如常见的 xterm
set ignorecase      # 设置搜索是否忽略大小写
set smartcase       # 智能大小写，默认忽略大小写，除非搜索内容里包含大写字母
set relativenumber  # 设置显示相对行号（其他行与当前行的距离）
set paste           # 打开粘贴模式（粘贴时禁用缩进等影响格式的内容）
set nopaste         # 关闭粘贴模式
set spell           # 允许拼写检查
set hlsearch        # 开启高亮查找
set nohlsearch      # 关闭高亮查找
set termguicolors   # Vim 开启真彩色
set ruler           # 总是显示光标位置
set nocompatible    # 设置不兼容原始 vi 模式，该设置必须在最开头
set incsearch       # 查找输入时动态增量显示查找结果
set insertmode      # Vim 始终处于插入模式下，使用 Ctrl+o 临时执行命令
set ff=unix         # 设置换行为 unix
set ff=dos          # 设置换行为 dos
set ff?             # 查看换行设置
set hidden          # 打开隐藏模式，未保存的缓存可以被切换走，或者关闭
set nohidden        # 关闭隐藏模式，未保存的缓存不能被切换走，或者关闭
set termcap         # 查看会从终端接收什么以及会发送给终端什么命令
set guicursor=      # 解决 SecureCRT/PenguiNet 中 NeoVim 局部奇怪字符问题
set t_RS= t_SH=     # 解决 SecureCRT/PenguiNet 中 Vim8.0 终端功能奇怪字符
set fo+=a           # 开启文本段的实时自动格式化
set showtabline=?   # 标签页显示方式，? 为 0 时隐藏标签页，1 会按需显示，2 会永久显示
inoremap vv <Esc>   # 插入模式下的 vv 键为 Esc 退出键，退出插入模式
nnoremap gh ^       # 普通模式下按 gh 键进行行首跳转，代替数字 0 进行行首跳转
nnoremap gl $       # 普通模式下按 gl 键进行行尾跳转，代替数字 $ 进行行尾跳转
```



## 常用插件

- [vim-commentary](https://github.com/tpope/vim-commentary)：批量注释工具，可以注释多行和去除多行注释。
- [NERDTree](https://github.com/preservim/nerdtree)：插件用于列出当前路径的目录树。
- [asyncrun.vim](https://github.com/skywind3000/asyncrun.vim)：插件使用 Vim 8、NeoVim 的异步机制，让你在后台运行 Shell 命令，并将结果实时显示到 Vim 的 Quickfix 窗口中。



## vim模式

```bash
普通模式             # 按 <Esc> 退出键或 Ctrl+[ 进入普通模式，左下角显示文件名或为空
插入模式             # 按 i 字母键进入插入模式，左下角显示 --INSERT--
可视模式             # 按 v 字母键进入可视模式，左下角显示 --VISUAL--
选择模式             # 按 {visual}+Ctrl+g 组合键进入选择模式，左下角显示 --SELECT-- 
替换模式             # 按 r 或 R 字母键开始替换模式，左下角显示 --REPLACE--
命令行模式           # 按 : 或者 / 或者 ? 开始命令行模式，左下角无明显信息
Ex 模式             # 按 Q 字母键进入 Ex 模式，与命令行模式类似，执行完命令后，会继续停留在 Ex 模式，按 :vi[sual] 退出 Ex 模式
```



## 外部命令

```bash
:!{command}         # 执行一次性 Shell 命令，例如 :!pwd，输出当前 Vim 模式下所处目录路径
:!!                 # 重新执行最近一次运行过的命令
:sh[ell]            # 启动一个交互的 Shell 执行多个命令，不需要退出Vim。exit 命令退出并返回 Vim
:!ls                # 运行外部命令 ls，并等待返回
:r !ls              # 将外部命令 ls 的输出捕获，并插入到光标后
:w !sudo tee %      # sudo 以后保存当前文件，也可以这样 :w !sudo tee % > /dev/null
:call system('ls')  # 调用 ls 命令，但是不显示返回内容
:!start notepad     # Windows 下启动 Notepad，最前面可以加 silent
:sil !start cmd     # Windows 下当前目录打开 cmd
:%!prog             # 运行文字过滤程序，如整理 JSON 格式 :%!python -m json.tool
```



## gui命令

```bash
:gui                         # UNIX 启动 GUI
:gui {fname}                 # 同上，并编辑 fname
:menu                        # 列出所有菜单
:menu {mpath}                # 列出 mpath 下的所有菜单
:menu {mpath} {rhs}          # 把 rhs 加入菜单 mpath
:menu {pri} {mpath} {rhs}    # 同上，并带有优先权 pri
:menu ToolBar.{name} {rhs}   # 把 rhs 加入工具栏
:tmenu {mpath} {text}        # 为菜单 mpath 加入工具提示
:unmenu {mpath}              # 删除菜单 mpath
```


## 自动命令

> 自动命令，是在指定事件发生时自动执行的命令。利用自动命令可以将重复的手工操作自动化，以提高编辑效率并减少人为操作的差错。

自动命令语法格式。

```bash
:au[tocmd] [group] {event} {aupat} [++once] [++nested] {command}
```

参数说明：

- group：组名是可选项，用于分组管理多条自动命令。
- event：[事件参数](resources/images/vim-events-type.jpg)，用于指明触发命令的一个或多个事件。
- pattern：限定针对符合匹配模式的文件执行命令。
- nested：嵌套标记是可选项，用于允许嵌套自动命令。
- command：指明需要执行的命令、函数或脚本。

```bash
:au[tocmd]                   # 查看所有自动命令，既包括 vimrc 文件中自定义的自动命令，也包括了各种插件定义的自动命令
:au[tocmd]!                  # 删除所有自动命令；此操作也将删除插件所定义的自动命令，请谨慎操作
:help autocommand-events     # 查看 自动命令事件 帮助文档
:help autocmd-patterns       # 查看匹配模式帮助文档
```

自动命令组

```bash
:h[elp] aug[roup]            # 查看自动命令组的帮助文档
```

> 通过 :augroup 命令，可以将多个相关联的自动命令分组管理，以便于按组来查看或删除自动命令。例如以下命令，将 C 语言开发的相关自动命令，组织在 “cprogram” 组内。详情亦见 **[vimrc 配置文件](./vimrc)** 中的自动代码折叠。

```bash
:augroup cprograms
:    autocmd!
:    autocmd FileReadPost *.c :set cindent
:    autocmd FileReadPost *.cpp :set cindent
:augroup END
```

如果我们针对同样的文件和同样的事件定义了多条自动命令，那么当满足触发条件时将分别执行多条自动命令。因此，建议在自动命令组的开头增加 :autocmd! 命令，以确保没有重复的自动命令存在。



## 快速修复窗口

> Quickfix 插件提供的功能，对编译调试程序非常有用。

```bash
:cope[n] [height]   # 打开 Quickfix 窗口以显示当前的错误列表，height 表示高度，单位为行
:lop[en] [height]   # 打开 Quickfix 窗口以显示当前窗口的位置列表
:ccl[ose]           # 关闭 Qiuckfix 窗口
:lcl[ose]           # 关闭显示当前窗口位置列表的窗口
:cw[indow] [height] # 出现识别错误时打开 Quickfix 窗口；否则什么也不做
:lw[indow] [height] # 等价于 :cwindow，除了使用显示当前窗口的位置列表
:cbo[ttom]          # 将光标放在 Quickfix 窗口的最后一行并滚动以使其可见
:lbo[ttom]          # 等价于 :cbottom，除了使用显示当前位置列表的窗口
:copen 10           # 打开 Quickfix 窗口，并且设置高度为 10
:cfir[st]           # 跳转到 Quickfix 窗口中第 1 个错误
:cla[st]            # 跳转到 Quickfix 窗口中最后 1 个错误
:cl[ist]            # 在 Quickfix 窗口中列出所有错误
:cc [N]             # 显示第 N 个错误的详细信息
:cn[ext]            # 定位到 Quickfix 窗口中下一个错误
:cp[rev]            # 定位到 Quickfix 窗口中上一个错误
:cold[er]           # 到前一个旧列表
:cnew               # 到后一个新列表
```



## 文件编码

```bash
:e ++enc=utf8 {file}         # UTF-8 编码打开 file 文件。
:w ++enc=gbk                 # 不管当前文件什么编码，把它转存成 GBK 编码。
:set encoding                # Vim 内部编码查看          
:set encoding=UTF-8          # Vim 内部编码修改
:set fileencoding            # 当前编辑的文件字符编码查看          
:set fileencoding=UTF-8      # 当前编辑的文件字符编码修改
:set fileencodings           # 查看 Vim 自动探测 fileencoding 的顺序列表          
:set fileencodings=UTF-8     # 修改 Vim 自动探测 fileencoding 的顺序列表
:h[elp] mbyte-options        # 查看 文件编码 帮助文档

```

文件编码说明。

- encoding（缩写：enc）: Vim 内部使用的字符编码方式，包括 Vim 的缓冲区、菜单文本、消息文本等。这个值一般用户不要设置，另外打开 Vim 之后再设置这个值也是没有意义的。大家可以将这个值看作是 Vim 程序自己的变量，如果在工作中遇到文件的编码问题，和 encoding 这个变量是万万没有关系的。
- fileencoding（缩写：fenc）: Vim 中当前编辑的文件的字符编码方式，Vim 保存文件时也会将文件保存为这种字符编码方式。
- fileencodings（缩写：fencs）: Vim 自动探测 fileencodings 的顺序列表，启动时会按照它所列出的字符编码方式 从前到后，逐一探测 即将打开的文件的字符编码方式，并且将 fileencoding 设置为最终探测到的字符编码方式。因此最好将 Unicode 编码方式放到这个列表的最前面，将拉丁语系编码方式 latin1 放到最后面。
- termencoding（缩写：tenc）: Vim 所工作的终端字符编码方式。如果在终端环境下使用 Vim，需要设置 termencoding 和终端所使用的编码一致。

文件编码种类。

- ucs-bom：非常严格的编码，非该编码的文件几乎没有可能被误判为 ucs-bom，因此一般放在第一位。
- utf-8：相当严格的编码，除了很短的文件之外也是几乎不可能被误判的，因此一般放在第二位。
- chinese：相对宽松的编码，在 Unix 里表示 GB2312，在 Windows 里表示 cp936，也就是 GBK 的别名。
- cp936：相对宽松的编码，cp936 是 GBK 的别名，是 GB2312 的超集，可以支持繁体汉字，也避免出现删除半个汉字的情况。
- latin1：最为宽松的编码，则放在列表的最后。

> 如果编码被误判了，解码后的结果就会显示为无法识别的乱码了。此时，如果你知道这个文件的正确编码，可以把 fileencodings 改成只有这一种编码，阻止任何 fall-back 发生，然后重新打开这个文件。


## 帮助信息

```bash
:h[elp] {command}   # 显示相关命令的帮助，也可以就输入 :help 而不跟命令，退出帮助需要输入 :q
:h tutor            # 入门文档
:h quickref         # 快速帮助
:h index            # 查询 Vim 所有键盘命令定义
:h summary          # 帮助你更好的使用内置帮助系统
:h Ctrl+H           # 查询普通模式下 Ctrl+H 是干什么的
:h i_Ctrl+H         # 查询插入模式下 Ctrl+H 是干什么的
:h i_<Up>           # 查询插入模式下方向键上是干什么的
:h pattern.txt      # 正则表达式帮助
:h eval             # 脚本编写帮助
:h function-list    # 查看 VimScript 的函数列表 
:h windows.txt      # 窗口使用帮助
:h tabpage.txt      # 标签页使用帮助
:h +timers          # 显示对 +timers 特性的帮助
:h :!               # 查看如何运行外部命令
:h tips             # 查看 Vim 内置的常用技巧文档
:h set-termcap      # 查看如何设置按键扫描码
:viu[sage]          # 显示普通命令的帮助。目的是为了模拟对应的 Nvi 命令
:exu[sage]          # 显示 Ex 命令的帮助。目的是为了模拟对应的 Nvi 命令
:ve[rsion]          # 查看 Vim 版本，同时也查看 Vim 载入配置文件的优先顺序及所在位置
                        # -------------------- 常用帮助信息 --------------------
:h aug[roup]            # 查看自动命令组的帮助文档
:h internal-variables   # 获取更多变量作用域的帮助信息
```



## 有点意思

```bash
xp                  # 交换两个字符
ddp                 # 交换两行
bi                  # 单词前加入字符
ea                  # 单词后加入字符
[N]r<Enter>         # 用一个换行符替换 N 个字符
g Ctrl+G            # 单词统计，按 g 再同时按 Ctrl+g 组合键
```



## 约定规范

> 本文档使用的各种特定字符，按照以下内容进行约定规范。

```bash
[]                  # 表示方括号里的字符可选，可达到减少键盘输入及重复操作的目的
[count]             # 可选的数值，可用在命令前以倍数或重复该命令
["x]                # 可选的用于存储文本的寄存器。参见 registers，x 代表从 'a-zA-z' 的英文字母
{}                  # 花括号里的内容是命令中必须出现的，但是可以取不同的值
{char1-char2}       # 在 char1 到 char2 区间内的 1 个字符，例如 {a-z} 是一个小写字母
{motion}            # 表示动作，移动光标的命令或动作
{operator}          # 表示操作符，用于对文本进行删除或修改操作的命令
{visual}            # 选中的文本区域，先用 v、V 或者 Ctrl+v 设定开始位置，然后用移动光标的命令来选定选择文本的另一端
Ctrl+{char}         # 作为控制字符输入的 {char}；即按住 Ctrl 键再按 {char}，{char} 是大写字母还是小写字母都一样
````



## 按键说明

> 下面这些按键的名称文档里会用到。它们也可以用在 :map 映射命令里，详情参见 **[vimrc 配置文件](./vimrc)**。

```bash
标识符               # 含义

<Nul>               # 数字 0 
<BS>                # 退格键 <Backspace>
<Tab>               # 制表符 <Tab>
<NL>                # 换行符
<FF>                # 换页符
<CR>                # 回车符 <Enter>
<Return>            # 同 <CR> 即 <Return> 
<Enter>             # 同 <CR> 即 <Enter> 
<Esc>               # 转义 
<Space>             # 空格键
<lt>                # 小于号 <
<Bslash>            # 反斜杠 \
<Bar>               # 竖杠 |
<Del>               # 删除键
<CSI>               # 命令序列引入
<xCSI>              # 图形界面的 CSI
<EOL>               # 行尾 (可以是 <CR>、<NL> 或 <CR><NL>，根据不同的系统和 fileformat 而定)

<Up>                # 光标上移键
<Down>              # 光标下移键
<Left>              # 光标左移键
<Right>             # 光标右移键
<S-Up>              # Shift ＋ 光标上移键
<S-Down>            # Shift ＋ 光标下移键
<S-Left>            # Shift ＋ 光标左移键
<S-Right>           # Shift ＋ 光标右移键
<C-Left>            # Ctrl ＋ 光标左移键
<C-Right>           # Ctrl ＋ 光标右移键
<F1>-<F12>          # 功能键 1 到 12
<S-F1>-<S-F12>      # Shift ＋ 功能键 1 到 12 
<Help>              # 帮助键
<Undo>              # 撤销键
<Insert>            # Insert 键
<Home>              # Home
<End>               # End
<PageUp>            # Page-up
<PageDown>          # Page-down

<kHome>             # 小键盘 Home (左上)
<kEnd>              # 小键盘 End (左下)
<kPageUp>           # 小键盘 Page-up (右上)
<kPageDown>         # 小键盘 Page-down (右下)
<kPlus>             # 小键盘 +
<kMinus>            # 小键盘 -
<kMultiply>         # 小键盘 *
<kDivide>           # 小键盘 /
<kEnter>            # 小键盘 Enter
<kPoint>            # 小键盘 小数点
<k0>-<k9>           # 小键盘 0 到 9

<S-...>             # Shift ＋ 其它键
<C-...>             # Ctr ＋ 其它键
<M-...>             # Alt ＋ 键 或 Meta ＋ 键
<A-...>             # 同 <M-...>    
```



## 网络资源

- 最新版本 Vim：https://github.com/vim/vim   
- Windows 版：https://github.com/vim/vim-win32-installer/releases
- 插件浏览：http://vimawesome.com
- 正确设置 Alt 换挡键：http://www.skywind.me/blog/archives/2021
- 视频教程：http://vimcasts.org/
- 中文帮助：http://vimcdoc.sourceforge.net/doc/help.html
- 中文版入门到精通：https://github.com/wsdjeg/vim-galore-zh_cn
- 五分钟脚本入门：http://www.skywind.me/blog/archives/2193
- 脚本精通：http://learnvimscriptthehardway.stevelosh.com/
- 十六年使用经验：http://zzapper.co.uk/vimtips.html
- 配色方案：http://vimcolors.com/



## 使用建议

- 多使用 :h[elp] {command} 获取显示相关命令的帮助文档，提高相关命令的认识水平。
- 永远不要用 Ctrl+C 代替 <Esc> 完全不同的含义，容易错误中断运行的后台脚本。
- 很多人使用 Ctrl+[ 代替 <Esc>，左手小指 Ctrl，右手小指 [ 熟练后很方便。
- 某些终端中使用 Vim 8 内嵌终端如看到奇怪字符，使用 :set t_RS= t_SH= 解决。
- 某些终端中使用 NeoVim 如看到奇怪字符，使用 :set guicursor= 解决。
- 多使用 ciw, ci[, ci", ci( 以及 diw, di[, di", di( 命令来快速改写/删除文本。
- 在行内左右移动光标时，多使用 w b e 或 W B E，而不是 h l 或方向键，这样会快很多。
- Shift 上档键相当于移动加速键， w b e 移动光标很慢，但是 W B E 走的很快。
- 自己要善于总结新技巧，例如移动到行首非空字符时用 0w 命令比 ^ 命令更容易输入。
- 在空白行使用 dip 命令可以删除所有临近的空白行，viw 可以选择连续空白。
- 缩进时使用 >8j >} <ap >ap =i} == 会方便很多；文档以 常规、6、9 个空格间隔缩进。
- 插入模式下，当你发现一个单词写错了，应该多用 Ctrl+W 这比 <Backspace> 退格键快。
- y d c 命令可以很好结合 f t 和 /X 例如 dt) 和 y/End<cr>。
- c d x 命令会自动填充寄存器 "1 到 "9 ，y 命令会自动填充 "0 寄存器。
- 用 v 命令选择文本时，可以用 0 掉头选择，有时很有用。
- 写文章时，可以写一段代码块，然后选中后执行 :!python 代码块就会被替换成结果。
- 搜索后经常使用 :nohl 来消除高亮，使用很频繁，可以 map 到 <Backspace> 上。
- 搜索时可以用 Ctrl+R Ctrl+W 插入光标下的单词，命令模式也能这么用。
- 映射按键时，应该默认使用 noremap ，只有特别需要的时候使用 map。
- 用 y 复制文本后，命令模式中 Ctrl+R 然后按双引号 0 可以插入之前复制内容。
- Windows 下的 GVim 可以设置 set rop=type:directx, renmode:5 增强显示。
- 当你觉得做某事很低效时，你应该停下来，然后思考正确的高效方式来完成。


## 相关书籍

[Vim 实用技巧（英文版）](https://www.amazon.com/Practical-Vim-Edit-Speed-Thought-ebook-dp-B018T6ZVPK/dp/B018T6ZVPK/ref=mt_other?_encoding=UTF8&me=&qid=) |  [Vim 实用技巧（中文版）](https://book.douban.com/subject/26967597/)



## vim键盘图

![vim 命令键盘图](resources/vim-commands_CN.png)



## 参考信息

- https://github.com/skywind3000/awesome-cheatsheets/blob/master/editors/vim.txt
- http://blog.g-design.net/post/4789778607/vim-cheat-sheet
- http://www.fprintf.net/vimCheatSheet.html
- http://www.ouyaoxiazai.com/article/24/654.html
- http://bbs.it-home.org/thread-80794-1-1.html
- http://www.lpfrx.com/wp-content/uploads/2008/09/vi.jpg
- https://github.com/glts/vim-cottidie/blob/master/autoload/cottidie/tips
- https://github.com/hobbestigrou/vimtips-fortune/blob/master/fortunes/vimtips
- http://michael.peopleofhonoronly.com/vim/



---


